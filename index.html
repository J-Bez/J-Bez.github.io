<!DOCTYPE html>
<html>
    <script src="https://aframe.io/releases/1.0.0/aframe.min.js"></script>
    <!-- we import arjs version without NFT but with marker + location based support -->
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <script src="https://hammerjs.github.io/dist/hammer.min.js"></script>
    <body style="margin : 0px; overflow: hidden;">
        <a-scene id="scene" embedded arjs>
        <a-marker preset="hiro">
            <a-box id="model" scale="2 2 2" position="0 0.5 0" material="color: yellow;"></a-box>
        </a-marker>
        <a-entity camera></a-entity>
        </a-scene>
    </body>
    <script>
	const scene = document.getElementById('scene')
	scene.addEventListener('touchmove', event => {movingTouch(event)})
	const model = document.getElementById('model')

	const manager = new Hammer.Manager(scene)
	const pinch = new Hammer.Pinch()
	manager.add(pinch)

	manager.on('pinch', function(ev) {
		if (!model) return

		const curr = model.getAttribute('scale')
		const scale = (ev.scale - 1)*0.01

		model.setAttribute('scale', {
			'x': curr.x + scale,
			'y': curr.y + scale,
			'z': curr.z + scale
		})
	})

	let firstY = null;
	let firstX = null;
	const movingTouch = event => {
		if (!model) return

		const curr = model.getAttribute('rotation')
		let touches = event.changedTouches

		for (touch of touches) {
			if (!firstY) {
				firstY = touch.pageY;
			}
			if (!firstX) {
				firstX = touch.pageX;
			}
			console.log(touch.pageY, firstY)
			if (touch.pageY < firstY) {
				if (touch.pageX < firstX) {
					model.setAttribute('rotation', {
						'x': curr.x - touch.pageY*(0.01*firstY-0.01*touch.pageY),
						'y': curr.y - touch.pageX*(0.01*firstX-0.01*touch.pageX),
						'z': curr.z
					})
				} else {
					model.setAttribute('rotation', {
						'x': curr.x - touch.pageY*(0.01*firstY-0.01*touch.pageY),
						'y': curr.y + touch.pageX*(0.01*touch.pageX-0.01*firstX),
						'z': curr.z
					})
				}
			} else {
				if (touch.pageX < firstX) {
					model.setAttribute('rotation', {
						'x': curr.x + touch.pageY*(0.01*touch.pageY-0.01*firstY),
						'y': curr.y - touch.pageX*(0.01*firstX-0.01*touch.pageX),
						'z': curr.z
					})
				} else {
					model.setAttribute('rotation', {
						'x': curr.x + touch.pageY*(0.01*touch.pageY-0.01*firstY),
						'y': curr.y + touch.pageX*(0.01*touch.pageX-0.01*firstX),
						'z': curr.z
					})
				}
			}
		}
	}
	/*    AFRAME.registerComponent("foo",{
		    init:function() {
		      var element = document.querySelector('body');
		      this.marker = document.querySelector('a-marker');
		      var model = document.getElementById('model');
		      var hammertime = new Hammer(element);
		      var pinch = new Hammer.Pinch(); // Pinch is not by default in the recognisers
		      hammertime.add(pinch); // add it to the Manager instance

		      hammertime.on('pan', (ev) => {
			let rotation = model.getAttribute("rotation")
			switch(ev.direction) {
			  case 2:
			    rotation.y = rotation.y + 4
			    break;
			  case 4:
			    rotation.y = rotation.y - 4
			    break;
			  case 8:
			    rotation.x = rotation.x + 4
			    break;
			  case 16:
			    rotation.x = rotation.x - 4
			    break;
			  default:
			    break;
			}
			model.setAttribute("rotation", rotation)
		      });

		     hammertime.on("pinch", (ev) => {
			let scale = {x:ev.scale, y:ev.scale, z:ev.scale}
			model.setAttribute("scale", scale);
		    });
		  }
		});*/
</script>
</html>
